<!doctype html>
<html>
<head>
<meta http-equiv='cache-control' content='no-cache'> 
<meta http-equiv='expires' content='0'> 
<meta http-equiv='pragma' content='no-cache'>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Location Reader</title>
<style>
*, *::before, *::after
{
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  background-color: black;
  color: white;
}
body
{
  padding: 0.2rem;
  text-align: center;
}
button
{
  border-radius: .4rem;
  padding: 0.2rem 0.8rem;
  font-size: 1rem;
  background: repeating-linear-gradient(0deg, #999, #666, #999);
}
button:enabled:hover
{
  background: repeating-linear-gradient(0deg, #AAA, #555, #AAA);
}
button:enabled:active
{
  background: repeating-linear-gradient(0deg, #BBB, #444, #BBB);
}
button:disabled
{
  color: #BBB;
}
#locationInfoTA
{
  width: 100%;
  height: 100rem;
  padding: .4rem;
  border: .2rem solid lightgrey;
  border-radius: .4rem;
  resize: vertical;
}  
.hcenter
{
  text-align: center;
}
</style>
<script>
let logger, log, logjs; // initialized in init () function

ael (window, 'error', (el, isInit, event) =>
{
  let msg = `Uncaught Global Error: "${event.stack}"`;
  alert (msg);
  log && log (msg);
});

function ael (el, eventName, listener, options)
{
  let listenerWithTry = (ev, el, isInit) =>
  {
    try { listener (ev?.target ?? el, isInit, ev); }
    catch (e)
    {
      log (`Uncaught error from listener on element with id "${el.id}", tagName: "${el.tagName}". ${e.stack}`);
    }
  };
  el.addEventListener (eventName, listenerWithTry, options);
  return listenerWithTry;
}

function toStrEvent (e)
{
  let obj = {};
  for (let k in e)
    obj[k] = e[k];
  return JSON.stringify (obj, (k, v) =>
  {
    return (v instanceof Node)   ? 'Node'   :
           (v instanceof Window) ? 'Window' : v; 
  }, 1);
}

class Logger
{
  constructor (el)
  {
    this.first = true;
    this.el = el;
  }

  log(...lineparts)
  {
    if (this.first)
      this.first = false;
    else
    {
      this.el.appendChild(
        document.createElement('br'));
    }

    let tn = document.createTextNode(
      lineparts.join(', '));
    this.el.appendChild (tn);  
  }

  reset()
  {
    this.first = true;
    this.el.textContent = '';
  }
}

let geoLoc = navigator.geolocation, watchPosId;
function captureCurrentLocation ()
{
  captureBtn.disabled = true;
  geoLoc.getCurrentPosition ((pos) =>
  {
     let { timestamp } = pos; 
    let { latitude, longitude, accuracy /* in meters */, headingFromNorth, speed /* meters */ } coords = pos.coords;
    ta.append (`${latitude} ${longitude} ${accuracy}\n`);
    captureBtn.disabled = false;
  }, (err) =>
  {
    log (`An error occured. Code: "${err.code}", Message: "${err.message}"`);
    captureBtn.disabled = false;
  },
  {
    maximumAge: 0 /* no cache */,
    timeout: 800 /* millis */,
    enableHighAccuracy: true /* needed to measure accurate disance, though it consumes more power  */
  }); 
}
 
function init()
{
  let logger = new Logger (output);
  let log = logger.log.bind(logger);
  (async () =>
  {
    let result = await navigator.permissions.query({ name: 'geolocation' });
    locationPermissionEl.textContent = result.state;
  })();
  ael (captureBtn, 'click', captureCurrentLocation);
}
</script>
</head>
<body onload="init()">
<br><br>
<label>Geolocation permission</label><span id="locationPermissionEl"></span>
<br><br>
<label><input type="checkbox" id="watchPosotionCb" /> Watch Position</label><span id="currentPosEl">N/A</span>
<br><br>
<button id="captureBtn">Capture current location</button>
<button id="captureBtn">Replace last captured Location with the current one</button>
<br><br>
<textarea id="locationInfoTA"></textarea>
<br><br>
<div id="output"></div>
</body>
</html>
