<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Location Reader</title>
<style>
*, *::before, *::after
{
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  background-color: black;
  color: white;
}
body
{
  padding: 0.2rem;
  text-align: center;
}
button
{
  border-radius: .4rem;
  padding: 0.2rem 0.8rem;
  font-size: 1rem;
  background: repeating-linear-gradient(0deg, #999, #666, #999);
}
button:enabled:hover
{
  background: repeating-linear-gradient(0deg, #AAA, #555, #AAA);
}
button:enabled:active
{
  background: repeating-linear-gradient(0deg, #BBB, #444, #BBB);
}
button:disabled
{
  color: #BBB;
}
#locationInfoTA, #outputEl
{
  display: inline-block;
  width: 80%;
  height: 8rem;
  padding: .4rem;
  border: .2rem solid lightgrey;
  border-radius: .4rem;
  resize: vertical;
}
#outputEl
{
  text-align: left;
}
.hcenter
{
  text-align: center;
}
</style>
<script>
let logger, log; // initialized in init () function

ael (window, 'error', (el, isInit, event) =>
{
  let msg = `Uncaught Global Error: "${event.stack}"`;
  alert (msg);
  log && log (msg);
});

function ael (el, eventName, listener, options)
{
  let listenerWithTry = (ev, el, isInit) =>
  {
    try { listener (ev?.target ?? el, isInit, ev); }
    catch (e)
    {
      log (`Uncaught error from listener on element with id "${el.id}", tagName: "${el.tagName}". ${e.stack}`);
    }
  };
  el.addEventListener (eventName, listenerWithTry, options);
  return listenerWithTry;
}

function bindTrailingArgs (fun, ...trailingArgs)
{
  return (...args) => fun.call (null, ...args, ...trailingArgs);
}
  
class Logger
{
  constructor (el)
  {
    this.first = true;
    this.el = el;
  }

  log (...lineparts)
  {
    if (this.first)
      this.first = false;
    else
    {
      this.el.appendChild (
        document.createElement ('br'));
    }

    let tn = document.createTextNode (
      lineparts.join (', '));
    this.el.appendChild (tn);  
  }

  reset()
  {
    this.first = true;
    this.el.textContent = '';
  }
}

let geoLoc = navigator.geolocation,
  watchPosId = 0,
  timerId = 0,
  lastReadTime = 0;

let geoLocOptions =
{
  maximumAge: 0 /* no cache */,
  timeout: 1200 /* millis */,
  enableHighAccuracy: true /* needed to measure accurate disance, though it consumes more power  */
};

function captureCurrentLocation (e, replaceLast)
{
  if (!geoLoc)
  {
    log ('Geolocation not availabavailable');
    return;
  }
  let successFun = replaceLast ? bindTrailingArgs (geoLocSuccess, true) : geoLocSuccess;
  captureBtn.disabled = true;
  geoLoc.getCurrentPosition (successFun, geoLocFailure, geoLocOptions); 
}

function geoLocSuccess (pos, replaceLast)
{
  lastReadTime = pos.timestamp;
  let { latitude, longitude, accuracy /* in meters */, headingFromNorth, speed /* meters */ } = pos.coords;
  let posText = `${latitude} ${longitude}`;

  if (watchPositionCb.checked)
  {
    currentPosEl.textContent = `${posText} ${accuracy} meters`;
  }
  else
  {
    currentPosEl.textContent = 'N/A';
    readTimeAgoEl.textContent = 'N/A';
  }
  
  if (replaceLast)
    locationInfoTA.append (`Replace`);

  locationInfoTA.append (`${posText}\n`);
  captureBtn.disabled = false;
}

function geoLocFailure (err)
{
  log (`An error occured. Code: "${err.code}", Message: "${err.message}"`);
  captureBtn.disabled = false;
}

function updateTimeAgo ()
{
  if (!lastReadTime)
    return;
  let seconds =  ~~ ((Date.now () - lastReadTime) / 1000);
  readTimeAgoEl.textContent = `${seconds} seconds ago`;
}
  
function init()
{
  alert (1);
  logger = new Logger (output);
  log = logger.log.bind (logger);

  log (`1 init start`);
  alert (2);
  (async () =>
  {
    log ('Reading permission....');
    let result = await navigator.permissions.query ({ name: 'geolocation' });
    locationPermissionEl.textContent = result.state;
  })();
  
  ael (watchPositionCb, 'change', el =>
  {
    if (timerId)
    {
      clearInterval (timerId);
      timerId = 0;
      geoLoc.clearWatch (watchPosId);
    }
    if (el.checked)
    {
      watchPosId = geoLoc.watchPosition (geoLocSuccess, geoLocFailure, geoLocOptions);
      timerId = setInterval (updateTimeAgo, 400);
    }
  });

  ael (captureBtn, 'click', captureCurrentLocation);
  ael (replaceCaptureBtn, 'click', bindTrailingArgs (captureCurrentLocation, true));
}
</script>
</head>
<body onload="init()">
<br><br>
<label>7 Geolocation permission: </label><span id="locationPermissionEl">N/A</span>
<br><br>
<label><input type="checkbox" id="watchPositionCb" /> Watch Position.</label>
<label>Position: </label><span id="currentPosEl">N/A</span>
<label>Updated: </label><span id="readTimeAgoEl">N/A</span>
<br><br>
<button id="captureBtn">Capture current location</button>
<button id="replaceCaptureBtn">Replace last captured Location with the current one</button>
<br><br>
<textarea id="locationInfoTA"></textarea>
<br><br>
<div id="output"></div>
</body>
</html>
