<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Location Reader</title>
<style>
*, *::before, *::after
{
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  background-color: black;
  color: white;
}
body
{
  padding: 0.2rem;
  text-align: center;
  font-family: monospace;
  font-size: .8rem;
}
input, textarea, button
{
  font-family: inherit;
  font-size: inherit;
}
button
{
  border-radius: .4rem;
  padding: 0.2rem 0.8rem;
  background: repeating-linear-gradient(0deg, #999, #666, #999);
}
button:enabled:hover
{
  background: repeating-linear-gradient(0deg, #AAA, #555, #AAA);
}
button:enabled:active
{
  background: repeating-linear-gradient(0deg, #BBB, #444, #BBB);
}
button:disabled
{
  color: #BBB;
  background: repeating-linear-gradient(0deg, #777, #666, #777);
}
#buttonsEl
{
  display: inline-block;
}
#buttonsEl td
{ 
  padding: .2rem;
}
#buttonsEl td > *
{ 
  width: 100%;
}
#locationInfoTA, #outputEl
{
  display: inline-block;
  width: 80%;
  height: 8rem;
  padding: .4rem;
  border: .2rem solid lightgrey;
  border-radius: .4rem;
  resize: vertical;
}
#areaInUnitsEl
{
  display: inline-block;
  text-align: left;
}
#outputEl
{
  overflow: scroll;
  text-align: left;
}
.hcenter
{
  text-align: center;
}
.disabled
{
  color: darkgrey;
}
.error
{
  color: red;
}
</style>
<script>
let log; // initialized in init () function

function convertEventToStr (event)
{
  let obj = {};
  for (let k in event)
    obj[k] = event[k];

  return JSON.stringify (obj, (k, v) =>
  {
    if (v instanceof Node)   return 'Node';
    if (v instanceof Window) return 'Window';
    return v;
  }, ' ');
}

function padNum (num, numOfDigits = 2, padStr = '0')
{
  return `${num}`.padStart (numOfDigits, padStr);
}

function readableTime (timestamp = Date.now ())
{
  let date = new Date (timestamp);
  let hrs = date.getHours ();
  if (hrs > 12)
    hrs -= 12;
  let mins = date.getMinutes ();
  let secs = date.getSeconds ();
  let millis = date.getMilliseconds();
  return `${padNum (hrs)}:${padNum (mins)}:${padNum (secs)}.${padNum (millis, 3)}`;
}
  
ael (window, 'error', (el, isInit, event) =>
{
  let msg = `Uncaught Global Error: ${convertEventToStr (event)} "${event.stack}"`;
  alert (msg);
  log && log (msg);
});

function ael (el, eventName, listener, options)
{
  // el, isInit will be provided, when manually called by the user, ev(ent) will be absent at that time.
  let listenerWithTry = (ev, el, isInit) =>
  {
    try { listener (ev?.target ?? el, isInit, ev); }
    catch (e)
    {
      log (`Uncaught error from listener on element with id "${el.id}", tagName: "${el.tagName}".\n${e.stack}`);
    }
  };
  el.addEventListener (eventName, listenerWithTry, options);
  return listenerWithTry;
}

function bindTrailingArgs (fun, ...trailingArgs)
{
  return (...args) => fun.call (null, ...args, ...trailingArgs);
}
  
class Logger
{
  constructor (el)
  {
    this.el = el;
  }

  log (...lineparts)
  {
    let ta = this.el;
    if (ta.hasChildNodes())
      ta.appendChild (
        document.createElement ('br'));

    let tn = document.createTextNode (
      lineparts.join (', '));
    ta.appendChild (tn);
    ta.scrollTop = ta.scrollHeight;
  }

  reset()
  {
    this.el.textContent = '';
  }
}

let geoLoc = navigator.geolocation,
  watchPosId = 0,
  timerId = 0,
  lastReadPosDetails = {};

let geoLocOptions =
{
  maximumAge: 0 /* no cache */,
  timeout: 1200 /* millis */,
  enableHighAccuracy: true /* needed to measure accurate disance, though it consumes more power  */
};

let replaceLastGeoLocSuccess = bindTrailingArgs (geoLocSuccess, true);
function captureCurrentLocation (el, isInit, event, replaceLast)
{
  let successFun = replaceLast ? replaceLastGeoLocSuccess : geoLocSuccess;
  readLocBtn.disabled = true;
  geoLoc.getCurrentPosition (successFun, geoLocFailure, geoLocOptions); 
}

function geoLocSuccess (pos, replaceLast)
{
  let timestamp = pos.timestamp;
  if (timestamp < (lastReadPosDetails?.timestamp ?? 0))
    return; // just keep using the latest value
  let { latitude, longitude, accuracy /* in meters *//*, headingFromNorth, speed *//* in meters */ } = pos.coords;
  lastReadPosDetails.timestamp = timestamp;
  lastReadPosDetails.latitude = latitude;
  lastReadPosDetails.longitude = longitude;
  
  let posText = `${latitude} ${longitude}`;
  currentPosEl.textContent = `${posText} ${accuracy} meters`;

  if (!watchPositionCb.checked)
    readTimeEl.textContent = readableTime (timestamp);
  
  if (replaceLast)
  {
    let text = locationInfoTA.value, tl = text.length;
    let li = text.lastIndexOf ('\n', text.length - 2);
    if (li !== -1)
      locationInfoTA.setRangeText ('', li + 1, tl);
  }
  locationInfoTA.append (`${posText}\n`);
  readLocBtn.disabled = false;
  // displayAreaInVariousUnits ();
}

function displayAreaInVariousUnits ()
{
  let latLngs = locationInfoTA.value.trim ().split (/[^-\d.]+/).map (numStr => +numStr);
  if (latLngs.length % 2 !== 0)  
    return log (`Invalid pairs of latitude and longitude. ${latLngs.length} entries.`);
  let coordinates = []; 
  for (let i = 0, li = latLngs.length - 1; i < li; i += 2)
  {
    let lat = latLngs[i], lng = latLngs[i + 1];
    if (!isValidLatitude (lat))
      return log (`Invalid latitude value: "${lat}"`);
    if (!isValidLongitude (lng))
      return log (`Invalid longitude value: "${lng}"`);
    coordinates.push ([lat, lng]);
  }
  let areaInSquareMeters = calculatePolygonAreaInSquareMeters (coordinates);

  /*
   50,000 m2 รท 10,000 = 5 Hectares
   40,000 m2 รท 4,046.85642 = 9.88421526 Acres
  */
  let acres = areaInSquareMeters / 4046.85642;
  areadInAcresLbl.textContent = `${acres.toFixed (4)}`;
  areadInCentsLbl.textContent = `${(acres * 100).toFixed (4)}`;
  areadInHectresLbl.textContent = `${(areaInSquareMeters / 10000).toFixed (4)}`;
  areadInSquareMetersLbl.textContent = `${areaInSquareMeters.toFixed (4)}`
    
  // The latitude must be a number between -90 and 90 and the longitude between -180 and 180.
  function isValidLatitude (num)
  {
    return Number.isFinite (num) && (num >= -90 && num <= 90)
  }

  function isValidLongitude (num)
  { // -180 and 180 are the same point
    return Number.isFinite (num) && (num >= -180 && num <= 180)
  }
  
  // Use to test: https://www.daftlogic.com/projects-google-maps-area-calculator-tool.htm
  // coordinates = [[ lat1, lng1 ], [ lat2, lng2 ], [ lat3, lng3 ], ...];
  function calculatePolygonAreaInSquareMeters (coordinates)
  {
    if (coordinates.length < 3)
      return 0;
    coordinates.push (coordinates[0]);
    
    let area = 0;
    for (let i = 0, li = coordinates.length - 1; i < li; i++)
    {
       let [ lat1, lng1 ] = coordinates[i];
       let [ lat2, lng2 ] = coordinates[i + 1];
       area += ( 
           toRadians (lng2 - lng1)
         * ( 2 + sinOfDegrees (lat1) + sinOfDegrees (lat2) )
               );
    }
  
    let earthRadiusInMeters = 6378137;
    area = (area * earthRadiusInMeters * earthRadiusInMeters) / 2;
    return Math.abs (area);

    function sinOfDegrees (degrees)
    {
      return Math.sin (toRadians (degrees));
    }
  
    function toRadians (degrees)
    {
      return (degrees * Math.PI) / 180;
    }
  }
}
  
function geoLocFailure (err)
{
  log (`An error occured while reaing Geolocation info. Code: "${err.code}", Message: "${err.message}"`);
  readLocBtn.disabled = false;
}

function updateTimeAgo ()
{
  if (!lastReadPosDetails)
    return;
  let seconds =  (Date.now () - lastReadPosDetails.time) / 1000;
  readTimeAgoEl.textContent = `${seconds.toFixed (2)} seconds ago`;
}
  
function init()
{
  let logger = new Logger (outputEl);
  log = logger.log.bind (logger);

  log (`32 init start`);
  (async () =>
  {
    log ('Reading permission....');
    let result = await navigator.permissions.query ({ name: 'geolocation' });
    let state = result.state;
    if (state === 'denied')
    {
      for (let el of [watchPositionCb, useLastReadLocBtn, 
        useLastReadReplaceLastReadLocBtn, readLocBtn, readReplaceLastReadLocBtn])
      {
        el.disabled = true;
      }
      watchPositionCb.parentNode.classList.add ('disabled');
      locationPermissionEl.classList.add ('error');
    }
    locationPermissionEl.textContent = state;
  })();
  
  ael (watchPositionCb, 'change', el =>
  {
    if (timerId)
    {
      clearInterval (timerId);
      timerId = 0;
      geoLoc.clearWatch (watchPosId);
    }
    if (el.checked)
    {
      timerId = setInterval (updateTimeAgo, 400);
      watchPosId = geoLoc.watchPosition (geoLocSuccess, geoLocFailure, geoLocOptions);
    }
  });
  
  ael (useLastReadLocBtn, 'click', () =>
  {
    //longitude
  });
  // ael (useLastReadReplaceLastReadLocBtn, 'click', bindTrailingArgs (captureCurrentLocation, true));
  ael (readLocBtn, 'click', captureCurrentLocation);
  ael (readReplaceLastReadLocBtn, 'click', bindTrailingArgs (captureCurrentLocation, true));

  ael (locationInfoTA, 'input', displayAreaInVariousUnits);
}
</script>
</head>
<body onload="init()">
<br>
<label>Geolocation permission: </label><span id="locationPermissionEl">N/A</span>
<br><br>
<label><input type="checkbox" id="watchPositionCb" /> Watch Position.</label>
<label>Position: </label><span id="currentPosEl">N/A</span>
<label>Updated: </label>
<span id="readTimeEl">N/A</span>
<span id="readTimeAgoEl">N/A</span><br><br>
<table id="buttonsEl">
  <tr>
    <td><button id="useLastReadLocBtn">1Use last read</button></td>
    <td><button id="useLastReadReplaceLastReadLocBtn">Use last read, replace last read</button><br></td>
  </tr>
  <tr>
    <td><button id="readLocBtn">Read</button></td>
    <td><button id="readReplaceLastReadLocBtn">Read, replace last read</button></td>
  </tr>
</table>
<br><br>
<textarea id="locationInfoTA"></textarea>
<br><br>
<div id="areaInUnitsEl">
  <label>Area in various units: </label><br>
  <label id="areadInAcresLbl">N/A</label> Acres<br>
  <label id="areadInCentsLbl">N/A</label> Cents<br>
  <label id="areadInHectresLbl">N/A</label> Hectres<br>
  <label id="areadInSquareMetersLbl">N/A</label> Square Meters
</div>
<br><br>
<div id="outputEl"></div>
</body>
</html>
