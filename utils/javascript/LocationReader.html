<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Location Reader</title>
<style>
*, *::before, *::after
{
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  background-color: black;
  color: white;
}
body
{
  padding: 0.2rem;
  text-align: center;
}
button
{
  border-radius: .4rem;
  padding: 0.2rem 0.8rem;
  font-size: 1rem;
  background: repeating-linear-gradient(0deg, #999, #666, #999);
}
button:enabled:hover
{
  background: repeating-linear-gradient(0deg, #AAA, #555, #AAA);
}
button:enabled:active
{
  background: repeating-linear-gradient(0deg, #BBB, #444, #BBB);
}
button:disabled
{
  color: #BBB;
  background: repeating-linear-gradient(0deg, #777, #666, #777);
}
#locationInfoTA, #outputEl
{
  display: inline-block;
  width: 80%;
  height: 8rem;
  padding: .4rem;
  border: .2rem solid lightgrey;
  border-radius: .4rem;
  resize: vertical;
}
#areaInUnitsEl
{
  display: inline-block;
  text-align: left;
}
#outputEl
{
  text-align: left;
}
.hcenter
{
  text-align: center;
}
.disabled
{
  color: darkgrey;
}
.error
{
  color: red;
}
</style>
<script>
let logger, log; // initialized in init () function

function toStr (event)
{
  let obj = {};
  for (let k in e) {
    obj[k] = e[k];
  }
  return JSON.stringify(obj, (k, v) =>
  {
    if (v instanceof Node) return 'Node';
    if (v instanceof Window) return 'Window';
    return v;
  }, ' ');
}
  
ael (window, 'error', (el, isInit, event) =>
{
  let msg = `0 Uncaught Global Error: ${toStr (event)} "${event.stack}"`;
  alert (msg);
  log && log (msg);
});

function ael (el, eventName, listener, options)
{
  let listenerWithTry = (ev, el, isInit) =>
  {
    try { listener (ev?.target ?? el, isInit, ev); }
    catch (e)
    {
      log (`Uncaught error from listener on element with id "${el.id}", tagName: "${el.tagName}".\n${e.stack}`);
    }
  };
  el.addEventListener (eventName, listenerWithTry, options);
  return listenerWithTry;
}

function bindTrailingArgs (fun, ...trailingArgs)
{
  return (...args) => fun.call (null, ...args, ...trailingArgs);
}
  
class Logger
{
  constructor (el)
  {
    this.el = el;
  }

  log (...lineparts)
  {
    this.el.appendChild (
      document.createElement ('br'));

    let tn = document.createTextNode (
      lineparts.join (', '));
    this.el.appendChild (tn);  
  }

  reset()
  {
    this.el.textContent = '';
  }
}

let geoLoc = navigator.geolocation,
  watchPosId = 0,
  timerId = 0,
  lastReadTime = 0;

let geoLocOptions =
{
  maximumAge: 0 /* no cache */,
  timeout: 1200 /* millis */,
  enableHighAccuracy: true /* needed to measure accurate disance, though it consumes more power  */
};

let replaceLastGeoLocSuccess = bindTrailingArgs (geoLocSuccess, true);
function captureCurrentLocation (e, replaceLast)
{
  if (!geoLoc)
    return log ('Geolocation feaure is not available in the browser');
  let successFun = replaceLast ? replaceLastGeoLocSuccess : geoLocSuccess;
  captureBtn.disabled = true;
  geoLoc.getCurrentPosition (successFun, geoLocFailure, geoLocOptions); 
}

function geoLocSuccess (pos, replaceLast)
{
  let currentReadTime = pos.timestamp;
  if (currentReadTime < lastReadTime)
    return; // just keep using the latest value
  lastReadTime = currentReadTime;
  let { latitude, longitude, accuracy /* in meters */, headingFromNorth, speed /* meters */ } = pos.coords;
  let posText = `${latitude} ${longitude}`;

  if (watchPositionCb.checked)
  {
    currentPosEl.textContent = `${posText} ${accuracy} meters`;
  }
  else
  {
    currentPosEl.textContent = 'N/A';
    readTimeAgoEl.textContent = 'N/A';
  }
  
  if (replaceLast)
  {
    let text = locationInfoTA.value, tl = text.length;
    let li = text.lastIndexOf ('\n', text.length - 2);
    if (li !== -1)
      locationInfoTA.setRangeText ('', li + 1, tl);
  }
  locationInfoTA.append (`${posText}\n`);
  captureBtn.disabled = false;
  // displayAreaInVariousUnits ();
}

function displayAreaInVariousUnits ()
{
  let latLngs = locationInfoTA.trim ().split (/\s+|\s*\n\s*/).map (numStr => +numStr);
  if (latLngs.length % 2 !== 0)  
    return log (`Invalid pairs of latitude and longitude. ${latLngs.length} entries.`);
  for (let i = 0, li = latLngs.length - 1; i < li; i++)
  {
    let lat = latLngs[i], lng = latLngs[i + 1];
    if (!isValidLatitude (lat))
      return log (`Invalid latitude value: "${lat}"`);
    if (!isValidLongitude (lng))
      return log (`Invalid latitude value: "${lng}"`);
  }

  let areaInSquareMeters = calculatePolygonAreaInSquareMeters (latLngs);
  /*
   50,000 m2 รท 10,000 = 5 Hectares
   40,000 m2 รท 4,046.85642 = 9.88421526 Acres
  */

  let acres = areaInSquareMeters / 4046.85642;
  areadInAcresLbl.textContent = `${acres.toFixed (4)}`;
  areadInCentsLbl.textContent = `${(acres * 100).toFixed (4)}`;
  areadInHectresLbl.textContent = `${(areaInSquareMeters * 10000).toFixed (4)}`;
  areadInSquareMetersLbl.textContent = `${areaInSquareMeters.toFixed (4)}`
    
  // The latitude must be a number between -90 and 90 and the longitude between -180 and 180.
  function isValidLatitude (num)
  {
    return Math.isFinite (num) && (num >= -90 && num <= 90)
  }

  function isValidLongitude (num)
  { // -180 and 180 are the same point
    return Math.isFinite (num) && (num >= -180 && num <= 180)
  }

  // coordinates = [[ lat1, lng1 ], [ lat2, lng2 ], [ lat3, lng3 ], ...];
  function calculatePolygonAreaInSquareMeters (coordinates)
  {
    if (coordinates.length < 3)
      return 0;
  
    let area = 0;
    for (let i = 0, li = coordinates.length - 1; i < li; i++)
    {
       let [ lat1, lng1 ] = coordinates[i];
       let [ lat2, lng2 ] = coordinates[i + 1];
       area += (
           toRadians (lng2 - lng1)
         * ( 2 + sinOfDegrees (lat1) + sinOfDegrees (lat2) )
               );
    }
  
    let earthRadiusInMeters = 6378137;
    area = (area * earthRadiusInMeters * earthRadiusInMeters) / 2;
    return Math.abs (area);

    function sinOfDegrees (degrees)
    {
      return Math.sin (toRadians (degrees));
    }
  
    function toRadians (degrees)
    {
      return (degrees * Math.PI) / 180;
    }
  }
}
  
function geoLocFailure (err)
{
  log (`An error occured while reaing Geolocation info. Code: "${err.code}", Message: "${err.message}"`);
  captureBtn.disabled = false;
}

function updateTimeAgo ()
{
  if (!lastReadTime)
    return;
  let seconds =  (Date.now () - lastReadTime) / 1000;
  readTimeAgoEl.textContent = `${seconds.toFixed (2)} seconds ago`;
}
  
function init()
{
  logger = new Logger (outputEl);
  log = logger.log.bind (logger);

  log (`10 init start`);
  (async () =>
  {
    log ('Reading permission....');
    let result = await navigator.permissions.query ({ name: 'geolocation' });
    let state = result.state;
    if (state === 'denied')
    {
      for (let el of [watchPositionCb, captureBtn, replaceCaptureBtn])
        el.disabled = true;
      watchPositionCb.parentNode.classList.add ('disabled');
      locationPermissionEl.classList.add ('error');
    }
    locationPermissionEl.textContent = state;
  })();
  
  ael (watchPositionCb, 'change', el =>
  {
    if (timerId)
    {
      clearInterval (timerId);
      timerId = 0;
      geoLoc.clearWatch (watchPosId);
    }
    if (el.checked)
    {
      timerId = setInterval (updateTimeAgo, 400);
      watchPosId = geoLoc.watchPosition (geoLocSuccess, geoLocFailure, geoLocOptions);
    }
  });

  ael (captureBtn, 'click', captureCurrentLocation);
  ael (replaceCaptureBtn, 'click', bindTrailingArgs (captureCurrentLocation, true));

  ael (locationInfoTA, 'input', displayAreaInVariousUnits);
}
</script>
</head>
<body onload="init()">
<br>
<label>Geolocation permission: </label><span id="locationPermissionEl">N/A</span>
<br><br>
<label><input type="checkbox" id="watchPositionCb" /> Watch Position.</label>
<label>Position: </label><span id="currentPosEl">N/A</span>
<label>Updated: </label><span id="readTimeAgoEl">N/A</span>
<br><br>
<button id="captureBtn">Capture current location</button>
<button id="replaceCaptureBtn">Replace last captured Location with the current one</button>
<br><br>
<textarea id="locationInfoTA"></textarea>
<br><br>
<div id="areaInUnitsEl">
  <label>Area in various units: </label><br>
  <label id="areadInAcresLbl">N/A</label> Acres<br>
  <label id="areadInCentsLbl">N/A</label> Cents<br>
  <label id="areadInHectresLbl">N/A</label> Hectres<br>
  <label id="areadInSquareMetersLbl">N/A</label> Square Meters
</div>
<br><br>
<div id="outputEl"></div>
</body>
</html>
