<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Location Reader</title>
<style>
*, *::before, *::after
{
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  background-color: black;
  color: white;
}
body
{
  padding: 0.2rem;
  text-align: center;
}
button
{
  border-radius: .4rem;
  padding: 0.2rem 0.8rem;
  font-size: 1rem;
  background: repeating-linear-gradient(0deg, #999, #666, #999);
}
button:enabled:hover
{
  background: repeating-linear-gradient(0deg, #AAA, #555, #AAA);
}
button:enabled:active
{
  background: repeating-linear-gradient(0deg, #BBB, #444, #BBB);
}
button:disabled
{
  color: #BBB;
  background: repeating-linear-gradient(0deg, #777, #666, #777);
}
#locationInfoTA, #outputEl
{
  display: inline-block;
  width: 80%;
  height: 8rem;
  padding: .4rem;
  border: .2rem solid lightgrey;
  border-radius: .4rem;
  resize: vertical;
}
#outputEl
{
  text-align: left;
}
.hcenter
{
  text-align: center;
}
.error
{
  color: red;
}
</style>
<script>
let logger, log; // initialized in init () function

ael (window, 'error', (el, isInit, event) =>
{
  let msg = `Uncaught Global Error: "${event.stack}"`;
  alert (msg);
  log && log (msg);
});

function ael (el, eventName, listener, options)
{
  let listenerWithTry = (ev, el, isInit) =>
  {
    try { listener (ev?.target ?? el, isInit, ev); }
    catch (e)
    {
      log (`Uncaught error from listener on element with id "${el.id}", tagName: "${el.tagName}". ${e.stack}`);
    }
  };
  el.addEventListener (eventName, listenerWithTry, options);
  return listenerWithTry;
}

function bindTrailingArgs (fun, ...trailingArgs)
{
  return (...args) => fun.call (null, ...args, ...trailingArgs);
}
  
class Logger
{
  constructor (el)
  {
    this.first = true;
    this.el = el;
  }

  log (...lineparts)
  {
    if (this.first)
      this.first = false;
    else
    {
      this.el.appendChild (
        document.createElement ('br'));
    }

    let tn = document.createTextNode (
      lineparts.join (', '));
    this.el.appendChild (tn);  
  }

  reset()
  {
    this.first = true;
    this.el.textContent = '';
  }
}
  
// coordinates = [[ lat1, lng1 ], [ lat2, lng2 ], [ lat3, lng3 ], ...];
function calculatePolygonArea (coordinates)
{
  if (coordinates.length < 3)
    return 0;
  
  let area = 0;
  for (let i = 0, len = coordinates.length; i < len; i++)
  {
     let [ lat1, lng1 ] = coordinates[i];
     let [ lat2, lng2 ] = coordinates[i + 1];
     area += toRadians (lng2 - lng1)
       * (2 + Math.sin (toRadians (lat1)) + Math.sin (toRadians (lat2)));
  }
  let earthRadiusInMeters = 6378137;
  area = (area * earthRadiusInMeters * earthRadiusInMeters) / 2;
  return Math.abs (area);
}

function toRadians (degrees)
{
  return (degrees * Math.PI) / 180;
}

let geoLoc = navigator.geolocation,
  watchPosId = 0,
  timerId = 0,
  lastReadTime = 0;

let geoLocOptions =
{
  maximumAge: 0 /* no cache */,
  timeout: 1200 /* millis */,
  enableHighAccuracy: true /* needed to measure accurate disance, though it consumes more power  */
};

function captureCurrentLocation (e, replaceLast)
{
  if (!geoLoc)
  {
    log ('Geolocation not availabavailable');
    return;
  }
  let successFun = replaceLast ? bindTrailingArgs (geoLocSuccess, true) : geoLocSuccess;
  captureBtn.disabled = true;
  geoLoc.getCurrentPosition (successFun, geoLocFailure, geoLocOptions); 
}

function geoLocSuccess (pos, replaceLast)
{
  lastReadTime = pos.timestamp;
  let { latitude, longitude, accuracy /* in meters */, headingFromNorth, speed /* meters */ } = pos.coords;
  let posText = `${latitude} ${longitude}`;

  if (watchPositionCb.checked)
  {
    currentPosEl.textContent = `${posText} ${accuracy} meters`;
  }
  else
  {
    currentPosEl.textContent = 'N/A';
    readTimeAgoEl.textContent = 'N/A';
  }
  
  if (replaceLast)
  {
    let text = locationInfoTA.value, tl = text.length;
    let li = text.lastIndexOf ('\n', text.length - 2);
    if (li !== -1)
      locationInfoTA.setRangeText ('', li + 1, tl);
  }
  locationInfoTA.append (`${posText}\n`);
  captureBtn.disabled = false;
}

function geoLocFailure (err)
{
  log (`An error occured. Code: "${err.code}", Message: "${err.message}"`);
  captureBtn.disabled = false;
}

function updateTimeAgo ()
{
  if (!lastReadTime)
    return;
  let seconds =  ~~ ((Date.now () - lastReadTime) / 1000);
  readTimeAgoEl.textContent = `${seconds} seconds ago`;
}
  
function init()
{
  logger = new Logger (outputEl);
  log = logger.log.bind (logger);

  log (`4 init start`);
  (async () =>
  {
    log ('Reading permission....');
    let result = await navigator.permissions.query ({ name: 'geolocation' });
    let state = result.state;
    if (state === 'denied')
    {
      for (let el of [watchPositionCb, captureBtn, replaceCaptureBtn])
        el.disabled = true;
      locationPermissionEl.classList.add ('error');  
    }
    locationPermissionEl.textContent = state;
  })();
  
  ael (watchPositionCb, 'change', el =>
  {
    if (timerId)
    {
      clearInterval (timerId);
      timerId = 0;
      geoLoc.clearWatch (watchPosId);
    }
    if (el.checked)
    {
      watchPosId = geoLoc.watchPosition (geoLocSuccess, geoLocFailure, geoLocOptions);
      timerId = setInterval (updateTimeAgo, 400);
    }
  });

  ael (captureBtn, 'click', captureCurrentLocation);
  ael (replaceCaptureBtn, 'click', bindTrailingArgs (captureCurrentLocation, true));
}
</script>
</head>
<body onload="init()">
<br>
<label>Geolocation permission: </label><span id="locationPermissionEl">N/A</span>
<br><br>
<label><input type="checkbox" id="watchPositionCb" /> Watch Position.</label>
<label>Position: </label><span id="currentPosEl">N/A</span>
<label>Updated: </label><span id="readTimeAgoEl">N/A</span>
<br><br>
<button id="captureBtn">Capture current location</button>
<button id="replaceCaptureBtn">Replace last captured Location with the current one</button>
<br><br>
<textarea id="locationInfoTA"></textarea>
<br><br>
<div id="outputEl"></div>
</body>
</html>
